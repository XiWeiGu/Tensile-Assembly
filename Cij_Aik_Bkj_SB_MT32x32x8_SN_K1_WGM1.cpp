/*******************************************************************************
* Copyright (C) 2016-2021 Advanced Micro Devices, Inc. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell cop-
* ies of the Software, and to permit persons to whom the Software is furnished
* to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IM-
* PLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
* FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
* COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
* IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNE-
* CTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*******************************************************************************/

/**************************************************
* This file was generated by Tensile:             *
* https://github.com/ROCmSoftwarePlatform/Tensile *
**************************************************/


#include "/root/Tensile/build/1_BenchmarkProblems/Cij_Aik_Bkj_SB_00/00_Final/source/Cij_Aik_Bkj_SB_MT32x32x8_SN_K1_WGM1.h"

#include "Cij_Aik_Bkj_SB_MT32x32x8_SN_K1_WGM1.h"


  /******************************************/
  /* Function Prefix                        */
  /******************************************/



/* tile parameters */
#define NUM_THREADS 256
#define SG0I 16  // SubGroup I方向
#define SG1J 16  // SubGroup J方向
#define TT0I 2   // ThreadTile 线程内核大小I方向
#define TT1J 2   // ThreadTile 线程内核大小J方向
#define MT0I (SG0I*TT0I) // MacroTile, SubGroup处理的宏块大小 I方向
#define MT1J (SG1J*TT1J) // MacroTile, SubGroup处理的宏块大小 I方向
#define VECTOR_WIDTH 2
#define GLOBAL_LOAD_VECTOR_WIDTH_A 1
#define GLOBAL_LOAD_VECTOR_WIDTH_B 1
#define GLOBAL_WRITE_VECTOR_WIDTH 2

/* DepthU parameters*/
#define CPSV (NUM_THREADS / MT0I * VECTOR_WIDTH)
#define LOCAL_SPLITU 1
#define UNROLL 8
#define LOCAL_DEPTHU (LOCAL_SPLITU*UNROLL)

/* other */
#define PAD 0
#define WORK_GROUP_MAPPING 1 // 工作组大小

/* num loads parallel and perpendicular to coalesced */
//# 当从全局内存加载所有数据到LDS时，如果需要多个加载指令，这些参数决定了哪些加载操作会从全局内存拉取哪些矩形数据到LDS。
//# NLC=1表示沿着共用维度进行一次加载，这将产生尽可能多的合并加载（coalescing），即每个加载操作尽量合并多个数据项。
//# NLC=-1表示沿着共用维度读取尽可能多的元素，这会导致最少的合并加载；然而，在这种情况下，每个加载之间的步长是一个静态值，因此缓冲区加载只需要一组寄存器，
//# 而NLC=1的情况需要在垂直维度上为每个加载计算一个地址，因为步长是一个核参数的倍数。
#define NLCA 1   // NumLoadsCoalescedA
#define NLCB 1
#define NLPA 1
#define NLPB 1

/* load sizes parallel and perpendicular to coalesced */
#define LSCA (MT0I/NLCA)                           // 32 / 1 = 32
#define LSPA (LOCAL_DEPTHU/NLPA)
#define LSCB (LOCAL_DEPTHU/NLCB)                   // 8 / 1 = 8
#define LSPB (MT1J/NLPB)
#define LVCA (LSCA/GLOBAL_LOAD_VECTOR_WIDTH_A)     // 32
#define LVCB (LSCB/GLOBAL_LOAD_VECTOR_WIDTH_B)     // 8
#define LVPA (LSPA/GLOBAL_LOAD_VECTOR_WIDTH_A)
#define LVPB (LSPB/GLOBAL_LOAD_VECTOR_WIDTH_B)
#define LDS_OFFSET_B 256
#define LDS_NUM_ELEMENTS 512

/* global memory indices */
#define GLOBAL_D(IDX0I, IDX1J) (( ((int64_t)IDX0I)*strideD0I + ((int64_t)IDX1J)*strideD1J ))
#define GLOBAL_C(IDX0I, IDX1J) (( ((int64_t)IDX0I)*strideC0I + ((int64_t)IDX1J)*strideC1J ))
#define GLOBAL_OFFSET_A(IDX0I, IDXK) (( ((int64_t)IDX0I)*strideA0I /* 1 */ + ((int64_t)IDXK)*strideAK /* 32 */))
#define GLOBAL_OFFSET_B(IDXK, IDX1J) (( ((int64_t)IDXK)*strideBK /* 1 */ +   ((int64_t)IDX1J)*strideB1J /* 32 */))

/* data types */
#define DATA_TYPE float
#define DEST_DATA_TYPE float
#define COMPUTE_DATA_TYPE float
#define MAGIC_DIV1(dividend, magicNumber, magicShift) ((uint64_t)(dividend) * magicNumber >> magicShift)

/* MAC's */
#define MAC(A,B,DST) DST += A*B
#define TYPE_MAC(MULA,MULB,DST) DST = MAC(MULA,MULB,DST);
#define TYPE_MAC_WRITE(DST,SRC,ALPHA,REG,BETA) DST = 0 != (BETA) ? (ALPHA)*(REG) + (BETA)*(SRC) : (ALPHA)*(REG);

/* 2x2 micro-tile */
#define MAC_2x2\
  TYPE_MAC(rA[0],rB[0],rC[0+0*TT0I]); \
  TYPE_MAC(rA[1],rB[0],rC[1+0*TT0I]); \
  TYPE_MAC(rA[0],rB[1],rC[0+1*TT0I]); \
  TYPE_MAC(rA[1],rB[1],rC[1+1*TT0I]); \

/* hard-coded initial strides CD*/
/* hard-coded initial strides AB */
#define strideD0I 1
#define strideC0I 1
#define strideA0I 1
#define strideBK 1


  /******************************************/
  /* Begin Kernel                           */
  /******************************************/

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
extern "C"
__global__ void
__launch_bounds__(256)
Cij_Aik_Bkj_SB_MT32x32x8_SN_K1_WGM1(
  float *D,
  float const * C,
  float const * A,
  float const * B,
  float const alpha,
  float const beta,
  unsigned int const strideD1J,
  unsigned int const strideC1J,
  unsigned int const strideAK,
  unsigned int const strideB1J,
  unsigned int size0I,
  unsigned int size1J,
  unsigned int sizeK,
  unsigned int staggerUIterParm,
  unsigned int problemNumGroupTiles0,
  unsigned int problemNumGroupTiles1 )
#pragma clang diagnostic pop

 {


  /******************************************/
  /* Allocate Resources                     */
  /******************************************/

  // Assume: serial = 1, 257

  unsigned int serial = hc_get_workitem_id(0); // 是线性ID究竟是局部的还是全局的??,先假设是局部的那范围是0~255
  unsigned int sgId = serial / (SG0I*SG1J);    // 工作项所在工作组ID, 恒为0??
#define SCALAR_ZERO (float)(0)
#define SCALAR_OOB_DATA SCALAR_ZERO
  /* registers for MAC's */           // MAC: Which instruction to use for MAC: MAD or FMA
  DEST_DATA_TYPE rC[TT0I*TT1J];       // TT: ThreadTile 每个线程计算内核大小, 每个线程计算的结果.
  DATA_TYPE rA[TT0I];                 // 暂存每个线程的A数据
  DATA_TYPE rB[TT1J];                 // 暂存每个线程的B数据

  /* registers for global->local */
  DATA_TYPE a_0_0_0_0;
  DATA_TYPE b_0_0_0_0;

  /* allocate local memory */
  __shared__ DATA_TYPE localMemory[LDS_NUM_ELEMENTS /* 512 */]; // 需要存Group大小的数据，包括A和B为（32 * 8）+ (32 * 8)

  typedef struct MagicStruct {unsigned M; int a; int s;} MagicStruct;
  const unsigned MAGIC_STRUCT_A = 0x80000000; // for extracting a-bit from shift kernarg
#define MAGIC_DIV2(dividend, magic) (((((uint64_t)(dividend) * magic.M) >> 32) + dividend*magic.a) >> magic.s)


  /******************************************/
  /* Local Read Addresses                   */
  /******************************************/


  /* local read addresses: tile assignments a/b */
  // serial是Group中的线性ID

  unsigned int lr0I = (serial % SG0I);          // (0~15)
  unsigned int lr1J = (serial / SG0I) % SG1J;   // (1 / 16) % 16 = 0 (257 / 16) % 16 = 0


  /* local read addresses: final offsets a */

  unsigned int localReadOffsetA = lr0I*VECTOR_WIDTH /* 2 */ + sgId*(MT0I+PAD);


  /* local read addresses: final offsets b */

  unsigned int localReadOffsetB = lr1J*VECTOR_WIDTH + sgId*(MT1J+PAD) + LDS_OFFSET_B; // 为什么加上LDS_OFFSET_B, 它是本地A的大小。


  /* local read addresses: declare addresses a */

  DATA_TYPE *localReadA;


  /* local read addresses: declare addresses b */

  DATA_TYPE *localReadB;



  /******************************************/
  /* Begin setupNewTile, isPap=False           */
  /******************************************/


  /* global read addresses: work-group */

  unsigned int wg0I = hc_get_group_id(0);   // 获取当前工作组在第一个维度（I维度）上的ID
  unsigned int wg1J = hc_get_group_id(1);   // 获取当前工作组在第二个维度（J维度）上的ID
  unsigned int nwg0I = hc_get_num_groups(0); // 获取工作组在第一个维度（I维度）上的总数
  unsigned int nwg1J = hc_get_num_groups(1); // 获取工作组在第一个维度（J维度）上的总数


  /* global read addresses: tile offset assignment a */
  // serial 为一个工作组的线性ID，在当前配置下范围0~255;

  unsigned int globalReadOffsetA0I = (serial % LVCA /* 32 */)*GLOBAL_LOAD_VECTOR_WIDTH_A /* 1 */ + (wg0I)*MT0I /* 工作组索引对应的偏移，需要加上MT系数 */;


  /* global read addresses: tile offset assignment b */

  unsigned int globalReadOffsetB1J = (serial/LVCB/* 8 */) + (wg1J)*MT1J;


  /* global read addresses: unroll assignment a */

  unsigned int globalReadOffsetAK = (serial / LVCA /* 32 */); // 0


  /* global read addresses: unroll assignment b */

  unsigned int globalReadOffsetBK = (serial%LVCB)*GLOBAL_LOAD_VECTOR_WIDTH_B /* 1 */;


  /* global read addresses: tile offsets a */

  unsigned int flattenedOffsetA_0_0 = globalReadOffsetA0I + 0 + 0*LSCA;
  flattenedOffsetA_0_0 = (flattenedOffsetA_0_0 > (size0I-1)) ? (size0I-1):flattenedOffsetA_0_0;
  unsigned int globalReadOffsetA0I_0_0 = flattenedOffsetA_0_0;


  /* global read addresses: tile offsets b */

  unsigned int flattenedOffsetB_0_0 = globalReadOffsetB1J + 0 + 0*LSPB;
  flattenedOffsetB_0_0 = (flattenedOffsetB_0_0 > (size1J-1)) ? (size1J-1):flattenedOffsetB_0_0;
  unsigned int globalReadOffsetB1J_0_0 = flattenedOffsetB_0_0;


  /* global read addresses: unroll offsets a */

  unsigned int globalReadOffsetAK_0_0 = globalReadOffsetAK + 0 + 0*LSPA;


  /* global read addresses: unroll offsets b */

  unsigned int globalReadOffsetBK_0_0 = globalReadOffsetBK + 0 + 0*LSCB;


  /* global read addresses: final offsets a */
  int64_t globalReadOffsetA_0_0_0_0 = GLOBAL_OFFSET_A( (globalReadOffsetA0I_0_0), (globalReadOffsetAK_0_0) );


  /* global read addresses: final offsets b */
  int64_t globalReadOffsetB_0_0_0_0 = GLOBAL_OFFSET_B( (globalReadOffsetBK_0_0), (globalReadOffsetB1J_0_0) );


  /* global read addresses: addresses a */

  DATA_TYPE const *globalReadA_0_0_0_0 = A + globalReadOffsetA_0_0_0_0;


  /* global read addresses: addresses b */

  DATA_TYPE const *globalReadB_0_0_0_0 = B + globalReadOffsetB_0_0_0_0;


  /* global read addresses: increments a */

  int64_t globalReadIncAK = (int64_t)strideAK*LOCAL_DEPTHU /* 8 */; // 32 * 8 = 256


  /* global read addresses: increments b */

  int64_t globalReadIncBK = (int64_t)strideBK /* 1 */ *LOCAL_DEPTHU /* 8 */; // 8


  /******************************************/
  /* Local Write Addresses                  */
  /******************************************/


  /* local write addresses: tile assignment A */
  unsigned int lwA0I = (serial%LVCA)*GLOBAL_LOAD_VECTOR_WIDTH_A /* 1 */;


  /* local write addresses: tile assignment B */
  unsigned int lwB1J = (serial/LVCB);


  /* local write addresses: unroll assignment A */
  unsigned int lwAK = (serial/LVCA);


  /* local write addresses: unroll assignment B */
  unsigned int lwBK = (serial%LVCB)*GLOBAL_LOAD_VECTOR_WIDTH_B;

  // 以上计算步骤与全局的读地址计算逻辑一致。


  /* local write addresses: first offset a */
  // 存A的逻辑与原始逻辑是一致的
  unsigned int localWriteFirstOffsetA = lwA0I + lwAK*(MT0I+PAD);

  /* local write addresses: first offset b */
  // 存B的逻辑不一致，相当于对原始数据做了转置。因为是B的列乘以A的行，此时对B的数据转置可以在内核计算时顺序取。
  unsigned int localWriteFirstOffsetB = lwB1J + lwBK*(MT1J+PAD) + LDS_OFFSET_B;


  /* local write addresses: final offsets A */
  unsigned int localWriteOffsetA_0_0_0_0 = localWriteFirstOffsetA + (0 + 0*LSCA) + (0 + 0*LSPA)*(MT0I+PAD);


  /* local write addresses: final offsets B */
  unsigned int localWriteOffsetB_0_0_0_0 = localWriteFirstOffsetB + (0 + 0*LSCB)*(MT1J+PAD) + (0 + 0*LSPB);


  /* local write addresses: declare addresses A */
  DATA_TYPE *localWriteA_0_0_0_0;


  /* local write addresses: declare addresses B */
  DATA_TYPE *localWriteB_0_0_0_0;


  /* local write init pointers A */
  localWriteA_0_0_0_0 = (DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);


  /* local write init pointers B */
  localWriteB_0_0_0_0 = (DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);

  /* declare loop num iterations */

  int numIterK;


  rC[0] = SCALAR_ZERO;
  rC[1] = SCALAR_ZERO;
  rC[2] = SCALAR_ZERO;
  rC[3] = SCALAR_ZERO;


  /* Compute summation loop num iter */
  if(alpha == (float)(0)) sizeK = 0;  // Short circuit check alpha=0, skip A*B 
  numIterK = sizeK /* 128 */ / LOCAL_DEPTHU /* 8 */; // 16, 在K方向上每次迭代的是8

  const unsigned origNumIter = numIterK;
  unsigned staggerUIter = (wg0I & staggerUIterParm);
  staggerUIter = (staggerUIter << 3); // shift so each stagger has 256-byte stride

  globalReadA_0_0_0_0 += (staggerUIter * globalReadIncAK); // apply stagger offset


  globalReadB_0_0_0_0 += (staggerUIter * globalReadIncBK); // apply stagger offset
VECTOR_WIDTH
  staggerUIter += 0; // add PrefetchGlobalRead

  /* local read addresses: init pointers a */

  localReadA = (DATA_TYPE *)(localMemory + localReadOffsetA);

  /* local read addresses: init pointers b */

  localReadB = (DATA_TYPE *)(localMemory + localReadOffsetB);


  /******************************************/
  /* End setupNewTile, isPap=False             */
  /******************************************/


  /******************************************/
  /* Unrolled Loop(s) - Begin               */
  /******************************************/
VECTOR_WIDTH
  while (numIterK-- > 0) {


    /******************************************/
    /* Unrolled Loop 1/1 - Begin              */
    /******************************************/



    /* Begin Each Unroll: Check VGPR.checkin for INT8 LW */


    /* global read A */
    a_0_0_0_0 = *(globalReadA_0_0_0_0 + 0);

    /* global read B */
    b_0_0_0_0 = *(globalReadB_0_0_0_0 + 0);

    /* global read inc A for sumK */
    globalReadA_0_0_0_0 = (DATA_TYPE const *)( ((DATA_TYPE const *)globalReadA_0_0_0_0) + 1*globalReadIncAK);
    if ((numIterK) == staggerUIter) {
      globalReadA_0_0_0_0 -= (origNumIter * globalReadIncAK); // wrap staggered offset back to row start
    }

    /* global read inc B for sumK */
    globalReadB_0_0_0_0 = (DATA_TYPE const *)( ((DATA_TYPE const *)globalReadB_0_0_0_0) + 1*globalReadIncBK);
    if ((numIterK) == staggerUIter) {
      globalReadB_0_0_0_0 -= (origNumIter * globalReadIncBK); // wrap staggered offset back to row start
    }


    __syncthreads(); //PGR=0, prior iter done reading lds


    /* local write a */

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wconditional-uninitialized"
    *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
#pragma clang diagnostic pop


    /* local write b */

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wconditional-uninitialized"
    *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
#pragma clang diagnostic pop


    __syncthreads(); //


    /* iter 0 */


    /* local read a */
    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0]; 
    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1]; 

    /* local read b */
    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0]; 
    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1]; 

    /* local read increment a */
    localReadA += LOCAL_SPLITU*(MT0I+PAD); // 获取下一组顺序数据地址

    /* local read increment b */
    localReadB += LOCAL_SPLITU*(MT1J+PAD); //获取下一组顺序数据地址
    MAC_2x2


    /* iter 1 */


    /* local read a */
    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0]; 
    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1]; 

    /* local read b */
    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0]; 
    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1]; 

    /* local read increment a */
    localReadA += LOCAL_SPLITU*(MT0I+PAD);

    /* local read increment b */
    localReadB += LOCAL_SPLITU*(MT1J+PAD);
    MAC_2x2


    /* iter 2 */


    /* local read a */
    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0]; 
    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1]; 

    /* local read b */
    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0]; 
    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1]; 

    /* local read increment a */
    localReadA += LOCAL_SPLITU*(MT0I+PAD);

    /* local read increment b */
    localReadB += LOCAL_SPLITU*(MT1J+PAD);
    MAC_2x2


    /* iter 3 */


    /* local read a */
    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0]; 
    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1]; 

    /* local read b */
    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0]; 
    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1]; 

    /* local read increment a */
    localReadA += LOCAL_SPLITU*(MT0I+PAD);

    /* local read increment b */
    localReadB += LOCAL_SPLITU*(MT1J+PAD);
    MAC_2x2


    /* iter 4 */


    /* local read a */
    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0]; 
    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1]; 

    /* local read b */
    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0]; 
    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1]; 

    /* local read increment a */
    localReadA += LOCAL_SPLITU*(MT0I+PAD);

    /* local read increment b */
    localReadB += LOCAL_SPLITU*(MT1J+PAD);
    MAC_2x2


    /* iter 5 */


    /* local read a */
    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0]; 
    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1]; 

    /* local read b */
    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0]; 
    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1]; 

    /* local read increment a */
    localReadA += LOCAL_SPLITU*(MT0I+PAD);

    /* local read increment b */
    localReadB += LOCAL_SPLITU*(MT1J+PAD);
    MAC_2x2


    /* iter 6 */


    /* local read a */
    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0]; 
    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1]; 

    /* local read b */
    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0]; 
    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1]; 

    /* local read increment a */
    localReadA += LOCAL_SPLITU*(MT0I+PAD);

    /* local read increment b */
    localReadB += LOCAL_SPLITU*(MT1J+PAD);
    MAC_2x2


    /* iter 7 (reset local read pointers iteration)  (swap and reset local write pointers iteration)  (swap local read pointers iteration)  */


    /* local read a */
    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0]; 
    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1]; 

    /* local read b */
    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0]; 
    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1]; 

    /* local read init pointers a */
    localReadA = (DATA_TYPE *)(localMemory + localReadOffsetA);

    /* local read init pointers b */
    localReadB = (DATA_TYPE *)(localMemory + localReadOffsetB);
    MAC_2x2


    /******************************************/
    /* Unrolled Loop - End                    */
    /******************************************/

  }


  /* Before NLL: Check VGPR.checkin for INT8 LW */


  /******************************************/
  /* Tail Loop                              */
  /******************************************/


  /* Compute tail loop num iter */
  numIterK = (((sizeK % LOCAL_DEPTHU) + LOCAL_SPLITU - 1) / LOCAL_SPLITU);


  /* remove stagger offsets for tail loop */

  globalReadA_0_0_0_0 += ((origNumIter - (staggerUIter - 0)) * globalReadIncAK); // remove stagger offset

  globalReadB_0_0_0_0 += ((origNumIter - (staggerUIter - 0)) * globalReadIncBK); // remove stagger offset


  /* Update M0 for DTLDS */



  /* global read a */


  /* global read A */
  a_0_0_0_0 = ( globalReadOffsetAK_0_0  + 0 >= (sizeK % LOCAL_DEPTHU) ) ? SCALAR_OOB_DATA : *(globalReadA_0_0_0_0 + 0);


  /* Update M0 for DTLDS */



  /* global read b */


  /* global read B */
  b_0_0_0_0 = ( globalReadOffsetBK_0_0  + 0 >= (sizeK % LOCAL_DEPTHU) ) ? SCALAR_OOB_DATA : *(globalReadB_0_0_0_0 + 0);


  __syncthreads(); //



  /* local write init pointers A */
  localWriteA_0_0_0_0 = (DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);


  /* local write init pointers B */
  localWriteB_0_0_0_0 = (DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);


  /* local write a */

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wconditional-uninitialized"
  *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
#pragma clang diagnostic pop


  /* local write b */

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wconditional-uninitialized"
  *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
#pragma clang diagnostic pop


  /* Recalc local read offsets */



  __syncthreads(); //


  /* tail loop: macs */

  while (numIterK-- > 0) {


    /* local read a */

    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0]; 
    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1]; 


    /* local read b */

    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0]; 
    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1]; 


    /* local read inc a */

    localReadA += LOCAL_SPLITU*(MT0I+PAD);


    /* local read inc b */

    localReadB += LOCAL_SPLITU*(MT1J+PAD);


    MAC_2x2

  }






  /* not-LocalSplitU: global write indices */

  unsigned int flattenedGlobalC0 = (wg0I)*MT0I + (serial % SG0I)*VECTOR_WIDTH;
  unsigned int flattenedGlobalC1 = (wg1J)*MT1J + (serial / SG0I)*VECTOR_WIDTH;
  unsigned int globalC0I = flattenedGlobalC0;
  unsigned int globalC1J = flattenedGlobalC1;


  /* not-LocalSplitU: global write */


  /* new vw0 offset - inc and extract tensor dims */
  globalC0I =   flattenedGlobalC0 +  0*SG0I*VECTOR_WIDTH;
  /* new vw1 offset - inc and extract tensor dims */
  globalC1J =   flattenedGlobalC1 + 0 + 0*SG1J*VECTOR_WIDTH;
  if (flattenedGlobalC0 + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (flattenedGlobalC1 + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( D[ GLOBAL_D( (uint64_t) globalC0I + 0, (uint64_t) globalC1J) ], C[ GLOBAL_C( (uint64_t) globalC0I + 0, (uint64_t) globalC1J) ], alpha, rC[0*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
  if (flattenedGlobalC0 + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (flattenedGlobalC1 + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( D[ GLOBAL_D( (uint64_t) globalC0I + 1, (uint64_t) globalC1J) ], C[ GLOBAL_C( (uint64_t) globalC0I + 1, (uint64_t) globalC1J) ], alpha, rC[0*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }

  /* new vw1 offset - inc and extract tensor dims */
  globalC1J VECTOR_WIDTH=   flattenedGlobalC1 + 1 + 0*SG1J*VECTOR_WIDTH;
  if (flattenedGlobalC0 + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (flattenedGlobalC1 + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( D[ GLOBAL_D( (uint64_t) globalC0I + 0, (uint64_t) globalC1J) ], C[ GLOBAL_C( (uint64_t) globalC0I + 0, (uint64_t) globalC1J) ], alpha, rC[0*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
  if (flattenedGlobalC0 + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (flattenedGlobalC1 + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( D[ GLOBAL_D( (uint64_t) globalC0I + 1, (uint64_t) globalC1J) ], C[ GLOBAL_C( (uint64_t) globalC0I + 1, (uint64_t) globalC1J) ], alpha, rC[0*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }


}

